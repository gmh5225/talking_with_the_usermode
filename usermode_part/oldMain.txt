/*
	DWORD pid = atoi(argv[1]);
	HANDLE device = CreateFile(L"\\\\.\\Protector", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);

	if (device == INVALID_HANDLE_VALUE) {
		std::cout << "Failed to open device" << std::endl;
		return 1;
	}

	// Send Pid to be protected
	bool success = DeviceIoControl(device, IOCTL_PROTECT_PID, &pid, sizeof(pid), nullptr, 0, &bytes, nullptr);
	CloseHandle(device);

	if (!success) {
		std::cout << "Failed in DeviceIoControl: " << GetLastError() << std::endl;
		return 1;
	}

	std::cout << "Protected process with pid: " << pid << std::endl;
*/

/*	
	SetConsoleTitle(L"TempMon");
	KeInterface Driver("\\\\.\\Protector");

	Driver.protectThis();

	DWORD procId = Driver.GetTargetPid();
	ULONG clientAddress = Driver.GetClientModule();

	DWORD localPlayer = Driver.ReadVirtualMemory<DWORD>(procId, clientAddress + local_player, sizeof(ULONG));

	DWORD inGround = Driver.ReadVirtualMemory<DWORD>(procId, localPlayer + fFlags, sizeof(ULONG));

	while (true) {
		DWORD inGround = Driver.ReadVirtualMemory<DWORD>(procId, localPlayer + fFlags, sizeof(ULONG));
		if ((GetAsyncKeyState(VK_SPACE) & 0x8000) && (inGround & 1 == 1))
		{
			// Jump
			Driver.WriteVirtualMemory(procId, clientAddress + force_jump, 0x5, 8);
			Sleep(50);
			// Restore
			Driver.WriteVirtualMemory(procId, clientAddress + force_jump, 0x4, 8);
		}
		if (GetAsyncKeyState(VK_F3))
			break;
		Sleep(10);
	}
	*/